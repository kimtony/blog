## 智能合约开发

### Solidity的特性
* 1、静态类型：
```
Solidity是一种静态类型语言，意味着变量的类型在编译时确定，并且在运行时不能改变。
```
* 2、合约导向：
```
Solidity是专门为智能合约设计的语言，合约是其基本构造单元。每个合约都可以包含状态变量、函数、事件和结构体。
```
* 3、继承与多态：
```
Solidity支持合约的继承，允许一个合约从另一个合约派生。支持多重继承和接口，提供了高度的代码复用和模块化能力。
```
* 4、库（Library）：
```
Solidity支持库，它们是不可变的合约，可以复用代码，提高代码的共享性和安全性。
```
* 5、事件（Events）：
```
事件用于在区块链上记录日志，前端应用可以监听这些事件以响应区块链上的变化。
```
* 6、接口（Interface）：
```
接口定义了一组没有实现的函数，可以用来规范合约的交互。任何实现接口的合约必须定义接口中声明的所有函数。
```

### Solidity的主要功能
* 1、智能合约的创建和管理：
```
通过合约关键字定义智能合约，包含状态变量、函数和构造函数等，用于管理区块链上的资产和逻辑。
```
* 2、函数定义和修饰符：
```
支持定义公共、私有、内部和外部函数，并通过修饰符（如view、pure、payable）控制函数的行为和访问权限。
```
* 3、状态变量和局部变量：
```
状态变量存储在区块链的合约存储中，局部变量在函数调用期间存储在栈中或内存中。
```
* 4、函数修饰符：
```
修饰符（Modifier）允许在函数执行之前或之后插入自定义代码，用于权限控制和输入校验等。
```
* 5、数据类型和结构体：
```
支持多种基本数据类型（如uint、int、bool、address）和复杂类型（如结构体struct和数组）。
```
* 6、数组和映射（Mapping）：
```
支持静态和动态数组，以及映射类型，用于存储和检索键值对。
```
* 7、合约间调用：
```
支持调用其他合约的函数，通过合约地址和接口进行调用。
```
* 8、错误处理：
```
提供了多种错误处理机制，如assert、require和revert，用于检测和处理异常情况。
```
* 9、以太坊虚拟机（EVM）兼容：
```
Solidity编译后的字节码在EVM上执行，保证了合约的跨平台运行。
```




### 在以太坊中，以下语句被视为修改链上状态：

```
写入状态变量。
释放事件。
创建其他合约。
使用selfdestruct.
通过调用发送以太币。
调用任何未标记view或pure的函数。
使用低级调用（low-level calls）。
使用包含某些操作码的内联汇编。
```


## 其他
```

onlyOwner 修饰符用于限制只有合约的所有者（即部署合约的地址）才能调用被修饰的函数。这样可以确保只有合约的所有者才有权限执行特定的操作，例如更新合约状态、设置参数、管理资金等。在 Solidity 中，修饰符允许在函数定义中添加额外的条件，以确保只有满足这些条件的调用者才能执行函数。


在以太坊和其他基于以太坊的区块链网络中，零地址（也称为零地址或零账户）是一个特殊的地址，其地址为 0x0000000000000000000000000000000000000000。零地址是一个有效的地址，但它没有对应的私钥，因此无法对其进行交易或发送代币。在智能合约中，通常会将零地址作为一个特殊的标志，用来表示一些特定的情况，比如代币销毁操作或某些合约功能的禁用状态。
```


### 有哪些常见的智能合约漏洞需要注意
* 安全问题和智能合约的代码、平台、编程语言、编程语言的版本都有关系。
```
整数溢出和下溢：一些数值在计算过程中可能会超出整数的最大值和最小值，发生意料之外的情况。我是通过 OpenZeppline 提供的 SafeMath 库来处理这种情况的。

可重入攻击：如果智能合约在发送 ETH 之前没有改变状态，那么攻击者可以递归调用智能合约，最后抽空合约里面的资产。为了避免这种情况，可以使用检查-生效-交互（checks-effects-interactions）的模式来避免。

短地址攻击：ERC20 正常的输入字节码是 136 位，如果低于 136 位，EVM 会在末位补 0。攻击者可以使用比正常短的地址，来诱导智能合约错误解析交易参数，这样可能导致资金丢失。我的解决方案就是验证字节码的长度。

selfdestruct 的使用：一定要慎用合约毁灭操作，因为一旦合约毁灭会导致资产丢失，无法找回。不过最新版本的 Solidity 删除了这个功能。

权限管理：正确配置权限和管理多签，避免权限被滥用。
```
